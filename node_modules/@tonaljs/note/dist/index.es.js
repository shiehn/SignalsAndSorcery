import { note, transpose as transpose$1, coordToNote } from '@tonaljs/core';
import { midiToNoteName, freqToMidi } from '@tonaljs/midi';

const NAMES = ["C", "D", "E", "F", "G", "A", "B"];
const toName = (n) => n.name;
const onlyNotes = (array) => array.map(note).filter((n) => !n.empty);
/**
 * Return the natural note names without octave
 * @function
 * @example
 * Note.names(); // => ["C", "D", "E", "F", "G", "A", "B"]
 */
function names(array) {
    if (array === undefined) {
        return NAMES.slice();
    }
    else if (!Array.isArray(array)) {
        return [];
    }
    else {
        return onlyNotes(array).map(toName);
    }
}
/**
 * Get a note from a note name
 *
 * @function
 * @example
 * Note.get('Bb4') // => { name: "Bb4", midi: 70, chroma: 10, ... }
 */
const get = note;
/**
 * Get the note name
 * @function
 */
const name = (note) => get(note).name;
/**
 * Get the note pitch class name
 * @function
 */
const pitchClass = (note) => get(note).pc;
/**
 * Get the note accidentals
 * @function
 */
const accidentals = (note) => get(note).acc;
/**
 * Get the note octave
 * @function
 */
const octave = (note) => get(note).oct;
/**
 * Get the note midi
 * @function
 */
const midi = (note) => get(note).midi;
/**
 * Get the note midi
 * @function
 */
const freq = (note) => get(note).freq;
/**
 * Get the note chroma
 * @function
 */
const chroma = (note) => get(note).chroma;
/**
 * Given a midi number, returns a note name. Uses flats for altered notes.
 *
 * @function
 * @param {number} midi - the midi note number
 * @return {string} the note name
 * @example
 * Note.fromMidi(61) // => "Db4"
 * Note.fromMidi(61.7) // => "D4"
 */
function fromMidi(midi) {
    return midiToNoteName(midi);
}
/**
 * Given a midi number, returns a note name. Uses flats for altered notes.
 */
function fromFreq(freq) {
    return midiToNoteName(freqToMidi(freq));
}
/**
 * Given a midi number, returns a note name. Uses flats for altered notes.
 */
function fromFreqSharps(freq) {
    return midiToNoteName(freqToMidi(freq), { sharps: true });
}
/**
 * Given a midi number, returns a note name. Uses flats for altered notes.
 *
 * @function
 * @param {number} midi - the midi note number
 * @return {string} the note name
 * @example
 * Note.fromMidiSharps(61) // => "C#4"
 */
function fromMidiSharps(midi) {
    return midiToNoteName(midi, { sharps: true });
}
/**
 * Transpose a note by an interval
 */
const transpose = transpose$1;
const tr = transpose$1;
/**
 * Transpose by an interval.
 * @function
 * @param {string} interval
 * @return {function} a function that transposes by the given interval
 * @example
 * ["C", "D", "E"].map(Note.transposeBy("5P"));
 * // => ["G", "A", "B"]
 */
const transposeBy = (interval) => (note) => transpose(note, interval);
const trBy = transposeBy;
/**
 * Transpose from a note
 * @function
 * @param {string} note
 * @return {function}  a function that transposes the the note by an interval
 * ["1P", "3M", "5P"].map(Note.transposeFrom("C"));
 * // => ["C", "E", "G"]
 */
const transposeFrom = (note) => (interval) => transpose(note, interval);
const trFrom = transposeFrom;
/**
 * Transpose a note by a number of perfect fifths.
 *
 * @function
 * @param {string} note - the note name
 * @param {number} fifhts - the number of fifths
 * @return {string} the transposed note name
 *
 * @example
 * import { transposeFifths } from "@tonaljs/note"
 * transposeFifths("G4", 1) // => "D"
 * [0, 1, 2, 3, 4].map(fifths => transposeFifths("C", fifths)) // => ["C", "G", "D", "A", "E"]
 */
function transposeFifths(noteName, fifths) {
    const note = get(noteName);
    if (note.empty) {
        return "";
    }
    const [nFifths, nOcts] = note.coord;
    const transposed = nOcts === undefined
        ? coordToNote([nFifths + fifths])
        : coordToNote([nFifths + fifths, nOcts]);
    return transposed.name;
}
const trFifths = transposeFifths;
const ascending = (a, b) => a.height - b.height;
const descending = (a, b) => b.height - a.height;
function sortedNames(notes, comparator) {
    comparator = comparator || ascending;
    return onlyNotes(notes).sort(comparator).map(toName);
}
function sortedUniqNames(notes) {
    return sortedNames(notes, ascending).filter((n, i, a) => i === 0 || n !== a[i - 1]);
}
/**
 * Simplify a note
 *
 * @function
 * @param {string} note - the note to be simplified
 * - sameAccType: default true. Use same kind of accidentals that source
 * @return {string} the simplified note or '' if not valid note
 * @example
 * simplify("C##") // => "D"
 * simplify("C###") // => "D#"
 * simplify("C###")
 * simplify("B#4") // => "C5"
 */
const simplify = (noteName) => {
    const note = get(noteName);
    if (note.empty) {
        return "";
    }
    return midiToNoteName(note.midi || note.chroma, {
        sharps: note.alt > 0,
        pitchClass: note.midi === null,
    });
};
/**
 * Get enharmonic of a note
 *
 * @function
 * @param {string} note
 * @param [string] - [optional] Destination pitch class
 * @return {string} the enharmonic note name or '' if not valid note
 * @example
 * Note.enharmonic("Db") // => "C#"
 * Note.enharmonic("C") // => "C"
 * Note.enharmonic("F2","E#") // => "E#2"
 */
function enharmonic(noteName, destName) {
    const src = get(noteName);
    if (src.empty) {
        return "";
    }
    // destination: use given or generate one
    const dest = get(destName ||
        midiToNoteName(src.midi || src.chroma, {
            sharps: src.alt < 0,
            pitchClass: true,
        }));
    // ensure destination is valid
    if (dest.empty || dest.chroma !== src.chroma) {
        return "";
    }
    // if src has no octave, no need to calculate anything else
    if (src.oct === undefined) {
        return dest.pc;
    }
    // detect any octave overflow
    const srcChroma = src.chroma - src.alt;
    const destChroma = dest.chroma - dest.alt;
    const destOctOffset = srcChroma > 11 || destChroma < 0
        ? -1
        : srcChroma < 0 || destChroma > 11
            ? +1
            : 0;
    // calculate the new octave
    const destOct = src.oct + destOctOffset;
    return dest.pc + destOct;
}
var index = {
    names,
    get,
    name,
    pitchClass,
    accidentals,
    octave,
    midi,
    ascending,
    descending,
    sortedNames,
    sortedUniqNames,
    fromMidi,
    fromMidiSharps,
    freq,
    fromFreq,
    fromFreqSharps,
    chroma,
    transpose,
    tr,
    transposeBy,
    trBy,
    transposeFrom,
    trFrom,
    transposeFifths,
    trFifths,
    simplify,
    enharmonic,
};

export { accidentals, ascending, chroma, index as default, descending, enharmonic, freq, fromFreq, fromFreqSharps, fromMidi, fromMidiSharps, get, midi, name, names, octave, pitchClass, simplify, sortedNames, sortedUniqNames, tr, trBy, trFifths, trFrom, transpose, transposeBy, transposeFifths, transposeFrom };
//# sourceMappingURL=index.es.js.map
