(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@tonaljs/core'), require('@tonaljs/midi')) :
  typeof define === 'function' && define.amd ? define(['exports', '@tonaljs/core', '@tonaljs/midi'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.Note = {}, global.core, global.midi$1));
}(this, (function (exports, core, midi$1) { 'use strict';

  var NAMES = ["C", "D", "E", "F", "G", "A", "B"];
  var toName = function (n) { return n.name; };
  var onlyNotes = function (array) {
      return array.map(core.note).filter(function (n) { return !n.empty; });
  };
  /**
   * Return the natural note names without octave
   * @function
   * @example
   * Note.names(); // => ["C", "D", "E", "F", "G", "A", "B"]
   */
  function names(array) {
      if (array === undefined) {
          return NAMES.slice();
      }
      else if (!Array.isArray(array)) {
          return [];
      }
      else {
          return onlyNotes(array).map(toName);
      }
  }
  /**
   * Get a note from a note name
   *
   * @function
   * @example
   * Note.get('Bb4') // => { name: "Bb4", midi: 70, chroma: 10, ... }
   */
  var get = core.note;
  /**
   * Get the note name
   * @function
   */
  var name = function (note) { return get(note).name; };
  /**
   * Get the note pitch class name
   * @function
   */
  var pitchClass = function (note) { return get(note).pc; };
  /**
   * Get the note accidentals
   * @function
   */
  var accidentals = function (note) { return get(note).acc; };
  /**
   * Get the note octave
   * @function
   */
  var octave = function (note) { return get(note).oct; };
  /**
   * Get the note midi
   * @function
   */
  var midi = function (note) { return get(note).midi; };
  /**
   * Get the note midi
   * @function
   */
  var freq = function (note) { return get(note).freq; };
  /**
   * Get the note chroma
   * @function
   */
  var chroma = function (note) { return get(note).chroma; };
  /**
   * Given a midi number, returns a note name. Uses flats for altered notes.
   *
   * @function
   * @param {number} midi - the midi note number
   * @return {string} the note name
   * @example
   * Note.fromMidi(61) // => "Db4"
   * Note.fromMidi(61.7) // => "D4"
   */
  function fromMidi(midi) {
      return midi$1.midiToNoteName(midi);
  }
  /**
   * Given a midi number, returns a note name. Uses flats for altered notes.
   */
  function fromFreq(freq) {
      return midi$1.midiToNoteName(midi$1.freqToMidi(freq));
  }
  /**
   * Given a midi number, returns a note name. Uses flats for altered notes.
   */
  function fromFreqSharps(freq) {
      return midi$1.midiToNoteName(midi$1.freqToMidi(freq), { sharps: true });
  }
  /**
   * Given a midi number, returns a note name. Uses flats for altered notes.
   *
   * @function
   * @param {number} midi - the midi note number
   * @return {string} the note name
   * @example
   * Note.fromMidiSharps(61) // => "C#4"
   */
  function fromMidiSharps(midi) {
      return midi$1.midiToNoteName(midi, { sharps: true });
  }
  /**
   * Transpose a note by an interval
   */
  var transpose = core.transpose;
  var tr = core.transpose;
  /**
   * Transpose by an interval.
   * @function
   * @param {string} interval
   * @return {function} a function that transposes by the given interval
   * @example
   * ["C", "D", "E"].map(Note.transposeBy("5P"));
   * // => ["G", "A", "B"]
   */
  var transposeBy = function (interval) { return function (note) {
      return transpose(note, interval);
  }; };
  var trBy = transposeBy;
  /**
   * Transpose from a note
   * @function
   * @param {string} note
   * @return {function}  a function that transposes the the note by an interval
   * ["1P", "3M", "5P"].map(Note.transposeFrom("C"));
   * // => ["C", "E", "G"]
   */
  var transposeFrom = function (note) { return function (interval) {
      return transpose(note, interval);
  }; };
  var trFrom = transposeFrom;
  /**
   * Transpose a note by a number of perfect fifths.
   *
   * @function
   * @param {string} note - the note name
   * @param {number} fifhts - the number of fifths
   * @return {string} the transposed note name
   *
   * @example
   * import { transposeFifths } from "@tonaljs/note"
   * transposeFifths("G4", 1) // => "D"
   * [0, 1, 2, 3, 4].map(fifths => transposeFifths("C", fifths)) // => ["C", "G", "D", "A", "E"]
   */
  function transposeFifths(noteName, fifths) {
      var note = get(noteName);
      if (note.empty) {
          return "";
      }
      var _a = note.coord, nFifths = _a[0], nOcts = _a[1];
      var transposed = nOcts === undefined
          ? core.coordToNote([nFifths + fifths])
          : core.coordToNote([nFifths + fifths, nOcts]);
      return transposed.name;
  }
  var trFifths = transposeFifths;
  var ascending = function (a, b) { return a.height - b.height; };
  var descending = function (a, b) { return b.height - a.height; };
  function sortedNames(notes, comparator) {
      comparator = comparator || ascending;
      return onlyNotes(notes).sort(comparator).map(toName);
  }
  function sortedUniqNames(notes) {
      return sortedNames(notes, ascending).filter(function (n, i, a) { return i === 0 || n !== a[i - 1]; });
  }
  /**
   * Simplify a note
   *
   * @function
   * @param {string} note - the note to be simplified
   * - sameAccType: default true. Use same kind of accidentals that source
   * @return {string} the simplified note or '' if not valid note
   * @example
   * simplify("C##") // => "D"
   * simplify("C###") // => "D#"
   * simplify("C###")
   * simplify("B#4") // => "C5"
   */
  var simplify = function (noteName) {
      var note = get(noteName);
      if (note.empty) {
          return "";
      }
      return midi$1.midiToNoteName(note.midi || note.chroma, {
          sharps: note.alt > 0,
          pitchClass: note.midi === null,
      });
  };
  /**
   * Get enharmonic of a note
   *
   * @function
   * @param {string} note
   * @param [string] - [optional] Destination pitch class
   * @return {string} the enharmonic note name or '' if not valid note
   * @example
   * Note.enharmonic("Db") // => "C#"
   * Note.enharmonic("C") // => "C"
   * Note.enharmonic("F2","E#") // => "E#2"
   */
  function enharmonic(noteName, destName) {
      var src = get(noteName);
      if (src.empty) {
          return "";
      }
      // destination: use given or generate one
      var dest = get(destName ||
          midi$1.midiToNoteName(src.midi || src.chroma, {
              sharps: src.alt < 0,
              pitchClass: true,
          }));
      // ensure destination is valid
      if (dest.empty || dest.chroma !== src.chroma) {
          return "";
      }
      // if src has no octave, no need to calculate anything else
      if (src.oct === undefined) {
          return dest.pc;
      }
      // detect any octave overflow
      var srcChroma = src.chroma - src.alt;
      var destChroma = dest.chroma - dest.alt;
      var destOctOffset = srcChroma > 11 || destChroma < 0
          ? -1
          : srcChroma < 0 || destChroma > 11
              ? +1
              : 0;
      // calculate the new octave
      var destOct = src.oct + destOctOffset;
      return dest.pc + destOct;
  }
  var index = {
      names: names,
      get: get,
      name: name,
      pitchClass: pitchClass,
      accidentals: accidentals,
      octave: octave,
      midi: midi,
      ascending: ascending,
      descending: descending,
      sortedNames: sortedNames,
      sortedUniqNames: sortedUniqNames,
      fromMidi: fromMidi,
      fromMidiSharps: fromMidiSharps,
      freq: freq,
      fromFreq: fromFreq,
      fromFreqSharps: fromFreqSharps,
      chroma: chroma,
      transpose: transpose,
      tr: tr,
      transposeBy: transposeBy,
      trBy: trBy,
      transposeFrom: transposeFrom,
      trFrom: trFrom,
      transposeFifths: transposeFifths,
      trFifths: trFifths,
      simplify: simplify,
      enharmonic: enharmonic,
  };

  exports.accidentals = accidentals;
  exports.ascending = ascending;
  exports.chroma = chroma;
  exports['default'] = index;
  exports.descending = descending;
  exports.enharmonic = enharmonic;
  exports.freq = freq;
  exports.fromFreq = fromFreq;
  exports.fromFreqSharps = fromFreqSharps;
  exports.fromMidi = fromMidi;
  exports.fromMidiSharps = fromMidiSharps;
  exports.get = get;
  exports.midi = midi;
  exports.name = name;
  exports.names = names;
  exports.octave = octave;
  exports.pitchClass = pitchClass;
  exports.simplify = simplify;
  exports.sortedNames = sortedNames;
  exports.sortedUniqNames = sortedUniqNames;
  exports.tr = tr;
  exports.trBy = trBy;
  exports.trFifths = trFifths;
  exports.trFrom = trFrom;
  exports.transpose = transpose;
  exports.transposeBy = transposeBy;
  exports.transposeFifths = transposeFifths;
  exports.transposeFrom = transposeFrom;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=index.js.map
