import { all } from '@tonaljs/chord-type';
import { note } from '@tonaljs/core';
import { modes } from '@tonaljs/pcset';

const namedSet = (notes) => {
    const pcToName = notes.reduce((record, n) => {
        const chroma = note(n).chroma;
        if (chroma !== undefined) {
            record[chroma] = record[chroma] || note(n).name;
        }
        return record;
    }, {});
    return (chroma) => pcToName[chroma];
};
function detect(source) {
    const notes = source.map((n) => note(n).pc).filter((x) => x);
    if (note.length === 0) {
        return [];
    }
    const found = findExactMatches(notes, 1);
    return found
        .filter((chord) => chord.weight)
        .sort((a, b) => b.weight - a.weight)
        .map((chord) => chord.name);
}
function findExactMatches(notes, weight) {
    const tonic = notes[0];
    const tonicChroma = note(tonic).chroma;
    const noteName = namedSet(notes);
    // we need to test all chormas to get the correct baseNote
    const allModes = modes(notes, false);
    const found = [];
    allModes.forEach((mode, index) => {
        // some chords could have the same chroma but different interval spelling
        const chordTypes = all().filter((chordType) => chordType.chroma === mode);
        chordTypes.forEach((chordType) => {
            const chordName = chordType.aliases[0];
            const baseNote = noteName(index);
            const isInversion = index !== tonicChroma;
            if (isInversion) {
                found.push({
                    weight: 0.5 * weight,
                    name: `${baseNote}${chordName}/${tonic}`,
                });
            }
            else {
                found.push({ weight: 1 * weight, name: `${baseNote}${chordName}` });
            }
        });
    });
    return found;
}
var index = { detect };

export { index as default, detect };
//# sourceMappingURL=index.es.js.map
