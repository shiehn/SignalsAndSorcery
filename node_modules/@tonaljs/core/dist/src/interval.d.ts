import { Named } from "./named";
import { Direction, IntervalCoordinates, Pitch, PitchCoordinates } from "./pitch";
export declare type IntervalName = string;
export declare type IntervalLiteral = IntervalName | Pitch | Named;
declare type Quality = "dddd" | "ddd" | "dd" | "d" | "m" | "M" | "P" | "A" | "AA" | "AAA" | "AAAA";
declare type Type = "perfectable" | "majorable";
export interface Interval extends Pitch, Named {
    readonly empty: boolean;
    readonly name: IntervalName;
    readonly num: number;
    readonly q: Quality;
    readonly type: Type;
    readonly step: number;
    readonly alt: number;
    readonly dir: Direction;
    readonly simple: number;
    readonly semitones: number;
    readonly chroma: number;
    readonly coord: IntervalCoordinates;
    readonly oct: number;
}
export interface NoInterval extends Partial<Interval> {
    readonly empty: true;
    readonly name: "";
    readonly acc: "";
}
declare type IntervalTokens = [string, string];
/**
 * @private
 */
export declare function tokenizeInterval(str?: IntervalName): IntervalTokens;
/**
 * Get interval properties. It returns an object with:
 *
 * - name: the interval name
 * - num: the interval number
 * - type: 'perfectable' or 'majorable'
 * - q: the interval quality (d, m, M, A)
 * - dir: interval direction (1 ascending, -1 descending)
 * - simple: the simplified number
 * - semitones: the size in semitones
 * - chroma: the interval chroma
 *
 * @param {string} interval - the interval name
 * @return {Object} the interval properties
 *
 * @example
 * import { interval } from '@tonaljs/core'
 * interval('P5').semitones // => 7
 * interval('m3').type // => 'majorable'
 */
export declare function interval(src: IntervalLiteral): Interval | NoInterval;
/**
 * @private
 *
 * forceDescending is used in the case of unison (#243)
 */
export declare function coordToInterval(coord: PitchCoordinates, forceDescending?: boolean): Interval;
export {};
