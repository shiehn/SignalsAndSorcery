{"version":3,"sources":["webpack://Crunker/webpack/universalModuleDefinition","webpack://Crunker/webpack/bootstrap","webpack://Crunker/./crunker.ts"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Crunker","sampleRate","this","_sampleRate","_context","_createContext","AudioContext","webkitAudioContext","mozAudioContext","async","filepaths","Promise","all","map","filepath","buffer","File","Blob","arrayBuffer","fetch","then","response","headers","has","includes","console","warn","split","decodeAudioData","buffers","output","createBuffer","_maxNumberOfChannels","_maxDuration","forEach","channelNumber","numberOfChannels","outputData","getChannelData","bufferData","length","set","_totalLength","offset","padStart","seconds","Error","updatedBuffer","Math","ceil","channelData","subarray","source","createBufferSource","connect","destination","start","type","recorded","_interleave","dataview","_writeHeaders","audioBlob","blob","url","_renderURL","element","_renderAudioElement","filename","a","document","createElement","style","display","href","download","click","callback","_isSupported","undefined","close","max","duration","reduce","b","ArrayBuffer","view","DataView","_writeString","setUint32","setUint16","_floatTo16BitPCM","tmp","min","setInt16","header","setUint8","charCodeAt","input","result","Float32Array","index","inputIndex","audio","controls","src","URL","webkitURL","createObjectURL"],"mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,UAAW,GAAIH,GACI,iBAAZC,QACdA,QAAiB,QAAID,IAErBD,EAAc,QAAIC,IARpB,CASGK,QAAQ,WACX,O,YCTE,IAAIC,EAAmB,GAGvB,SAASC,EAAoBC,GAG5B,GAAGF,EAAiBE,GACnB,OAAOF,EAAiBE,GAAUP,QAGnC,IAAIC,EAASI,EAAiBE,GAAY,CACzCC,EAAGD,EACHE,GAAG,EACHT,QAAS,IAUV,OANAU,EAAQH,GAAUI,KAAKV,EAAOD,QAASC,EAAQA,EAAOD,QAASM,GAG/DL,EAAOQ,GAAI,EAGJR,EAAOD,QA0Df,OArDAM,EAAoBM,EAAIF,EAGxBJ,EAAoBO,EAAIR,EAGxBC,EAAoBQ,EAAI,SAASd,EAASe,EAAMC,GAC3CV,EAAoBW,EAAEjB,EAASe,IAClCG,OAAOC,eAAenB,EAASe,EAAM,CAAEK,YAAY,EAAMC,IAAKL,KAKhEV,EAAoBgB,EAAI,SAAStB,GACX,oBAAXuB,QAA0BA,OAAOC,aAC1CN,OAAOC,eAAenB,EAASuB,OAAOC,YAAa,CAAEC,MAAO,WAE7DP,OAAOC,eAAenB,EAAS,aAAc,CAAEyB,OAAO,KAQvDnB,EAAoBoB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQnB,EAAoBmB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKX,OAAOY,OAAO,MAGvB,GAFAxB,EAAoBgB,EAAEO,GACtBX,OAAOC,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOnB,EAAoBQ,EAAEe,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRvB,EAAoB2B,EAAI,SAAShC,GAChC,IAAIe,EAASf,GAAUA,EAAO2B,WAC7B,WAAwB,OAAO3B,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAK,EAAoBQ,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRV,EAAoBW,EAAI,SAASiB,EAAQC,GAAY,OAAOjB,OAAOkB,UAAUC,eAAe1B,KAAKuB,EAAQC,IAGzG7B,EAAoBgC,EAAI,GAIjBhC,EAAoBA,EAAoBiC,EAAI,G,mlCC3DhCC,E,WAOnB,aAA6E,6DAAJ,GAAI,IAA/DC,kBAA+D,MAAlD,MAAkD,YAC3EC,KAAKC,YAAcF,EACnBC,KAAKE,SAAWF,KAAKG,iB,qDAQvB,WAEE,OADAzC,OAAO0C,aAAe1C,OAAO0C,cAAiB1C,OAAe2C,oBAAuB3C,OAAe4C,gBAC5F,IAAIF,e,wBAMbG,iBAA4E,kCAAxDC,EAAwD,yBAAxDA,EAAwD,gBAC1E,aAAaC,QAAQC,IACnBF,EAAUG,KAAIJ,eAAOK,GACnB,IAAIC,EAkBJ,OAfEA,EADED,aAAoBE,MAAQF,aAAoBG,WACnCH,EAASI,oBAETC,MAAML,GAAUM,MAAK,SAACC,GASnC,OARIA,EAASC,QAAQC,IAAI,kBAAoBF,EAASC,QAAQzC,IAAI,gBAAiB2C,SAAS,WAC1FC,QAAQC,KAAR,2EAEIL,EAASC,QAAQzC,IAAI,gBAAiB8C,MAAM,KAAK,GAFrD,sDAGgDb,EAHhD,OAOKO,EAASH,uBAIP,EAAKd,SAASwB,gBAAgBb,S,wBAYjD,SAAWc,GACT,IAAMC,EAAS5B,KAAKE,SAAS2B,aAC3B7B,KAAK8B,qBAAqBH,GAC1B3B,KAAKC,YAAcD,KAAK+B,aAAaJ,GACrC3B,KAAKC,aAgBP,OAbA0B,EAAQK,SAAQ,SAACnB,GACf,IAAK,IAAIoB,EAAgB,EAAGA,EAAgBpB,EAAOqB,iBAAkBD,IAAiB,CAIpF,IAHA,IAAME,EAAaP,EAAOQ,eAAeH,GACnCI,EAAaxB,EAAOuB,eAAeH,GAEhCnE,EAAI+C,EAAOuB,eAAeH,GAAeK,OAAS,EAAGxE,GAAK,EAAGA,IACpEqE,EAAWrE,IAAMuE,EAAWvE,GAG9B8D,EAAOQ,eAAeH,GAAeM,IAAIJ,OAItCP,I,yBAUT,SAAYD,GACV,IAAMC,EAAS5B,KAAKE,SAAS2B,aAC3B7B,KAAK8B,qBAAqBH,GAC1B3B,KAAKwC,aAAab,GAClB3B,KAAKC,aAEHwC,EAAS,EAUb,OARAd,EAAQK,SAAQ,SAACnB,GACf,IAAK,IAAIoB,EAAgB,EAAGA,EAAgBpB,EAAOqB,iBAAkBD,IACnEL,EAAOQ,eAAeH,GAAeM,IAAI1B,EAAOuB,eAAeH,GAAgBQ,GAGjFA,GAAU5B,EAAOyB,UAGZV,I,sBAaT,SAASf,GAA6E,IAAxD6B,EAAwD,uDAArC,EAAGC,EAAkC,uDAAhB,EACpE,GAAgB,IAAZA,EAAe,OAAO9B,EAE1B,GAAI6B,EAAW,EAAG,MAAM,IAAIE,MAAM,8DAClC,GAAID,EAAU,EAAG,MAAM,IAAIC,MAAM,6DAQjC,IANA,IAAMC,EAAgB7C,KAAKE,SAAS2B,aAClChB,EAAOqB,iBACPY,KAAKC,KAAKlC,EAAOyB,OAASK,EAAU9B,EAAOd,YAC3Cc,EAAOd,YAGAkC,EAAgB,EAAGA,EAAgBpB,EAAOqB,iBAAkBD,IAAiB,CACpF,IAAMe,EAAcnC,EAAOuB,eAAeH,GAC1CY,EACGT,eAAeH,GACfM,IAAIS,EAAYC,SAAS,EAAGH,KAAKC,KAAKL,EAAW7B,EAAOd,YAAc,GAAI,GAE7E8C,EACGT,eAAeH,GACfM,IACCS,EAAYC,SAASH,KAAKC,KAAKL,EAAW7B,EAAOd,YAAc,EAAG8C,EAAcP,OAAS,GACzFQ,KAAKC,MAAML,EAAWC,GAAW9B,EAAOd,aAI9C,OAAO8C,I,kBAMT,SAAKhC,GACH,IAAMqC,EAASlD,KAAKE,SAASiD,qBAM7B,OAJAD,EAAOrC,OAASA,EAChBqC,EAAOE,QAAQpD,KAAKE,SAASmD,aAC7BH,EAAOI,QAEAJ,I,oBAaT,SAAOrC,GAAuE,IAAlD0C,EAAkD,uDAAnC,YACnCC,EAAWxD,KAAKyD,YAAY5C,GAC5B6C,EAAW1D,KAAK2D,cAAcH,GAC9BI,EAAY,IAAI7C,KAAK,CAAC2C,GAAW,CAAEH,SAEzC,MAAO,CACLM,KAAMD,EACNE,IAAK9D,KAAK+D,WAAWH,GACrBI,QAAShE,KAAKiE,oBAAoBL,M,sBAUtC,SAASC,GAA6D,IAAjDK,EAAiD,uDAA9B,UAChCC,EAAIC,SAASC,cAAc,KAOjC,OALAF,EAAEG,MAAMC,QAAU,OAClBJ,EAAEK,KAAOxE,KAAK+D,WAAWF,GACzBM,EAAEM,SAAF,UAAgBP,EAAhB,YAA4BL,EAAKN,KAAK9B,MAAM,KAAK,IACjD0C,EAAEO,QAEKP,I,0BAUT,SAAgBQ,GACd,OAAO3E,KAAK4E,oBAAiBC,EAAYF,M,mBAM3C,WAEE,OADA3E,KAAKE,SAAS4E,QACP9E,O,0BAQT,SAAqB2B,GACnB,OAAOmB,KAAKiC,IAAL,MAAAjC,KAAI,EAAQnB,EAAQhB,KAAI,SAACE,GAAD,OAAYA,EAAOmE,gB,kCAQpD,SAA6BrD,GAC3B,OAAOmB,KAAKiC,IAAL,MAAAjC,KAAI,EAAQnB,EAAQhB,KAAI,SAACE,GAAD,OAAYA,EAAOqB,wB,0BAQpD,SAAqBP,GACnB,OAAOA,EAAQhB,KAAI,SAACE,GAAD,OAAYA,EAAOyB,UAAQ2C,QAAO,SAACd,EAAGe,GAAJ,OAAUf,EAAIe,IAAG,K,0BAQxE,WACE,MAAO,iBAAkBxH,QAAU,uBAAwBA,QAAU,oBAAqBA,S,2BAU5F,SAAsBmD,GACpB,IAAMG,EAAc,IAAImE,YAAY,GAAqB,EAAhBtE,EAAOyB,QAC1C8C,EAAO,IAAIC,SAASrE,GAgB1B,OAdAhB,KAAKsF,aAAaF,EAAM,EAAG,QAC3BA,EAAKG,UAAU,EAAG,GAAqB,EAAhB1E,EAAOyB,QAAY,GAC1CtC,KAAKsF,aAAaF,EAAM,EAAG,QAC3BpF,KAAKsF,aAAaF,EAAM,GAAI,QAC5BA,EAAKG,UAAU,GAAI,IAAI,GACvBH,EAAKI,UAAU,GAAI,GAAG,GACtBJ,EAAKI,UAAU,GAAI,GAAG,GACtBJ,EAAKG,UAAU,GAAIvF,KAAKC,aAAa,GACrCmF,EAAKG,UAAU,GAAuB,EAAnBvF,KAAKC,aAAiB,GACzCmF,EAAKI,UAAU,GAAI,GAAG,GACtBJ,EAAKI,UAAU,GAAI,IAAI,GACvBxF,KAAKsF,aAAaF,EAAM,GAAI,QAC5BA,EAAKG,UAAU,GAAoB,EAAhB1E,EAAOyB,QAAY,GAE/BtC,KAAKyF,iBAAiBL,EAAMvE,EAAQ,M,8BAQ7C,SAAyB6C,EAAoB7C,EAAsB4B,GACjE,IAAK,IAAI3E,EAAI,EAAGA,EAAI+C,EAAOyB,OAAQxE,IAAK2E,GAAU,EAAG,CACnD,IAAMiD,EAAM5C,KAAKiC,KAAK,EAAGjC,KAAK6C,IAAI,EAAG9E,EAAO/C,KAC5C4F,EAASkC,SAASnD,EAAQiD,EAAM,EAAU,MAANA,EAAqB,MAANA,GAAc,GAGnE,OAAOhC,I,0BAQT,SAAqBA,EAAoBjB,EAAgBoD,GACvD,IAAK,IAAI/H,EAAI,EAAGA,EAAI+H,EAAOvD,OAAQxE,IACjC4F,EAASoC,SAASrD,EAAS3E,EAAG+H,EAAOE,WAAWjI,M,yBASpD,SAAoBkI,GAQlB,IAPA,IAAMnF,EAASmF,EAAM5D,eAAe,GAClCE,EAAyB,EAAhBzB,EAAOyB,OAChB2D,EAAS,IAAIC,aAAa5D,GAExB6D,EAAQ,EACVC,EAAa,EAERD,EAAQ7D,GACb2D,EAAOE,KAAWtF,EAAOuF,GACzBH,EAAOE,KAAWtF,EAAOuF,GACzBA,IAEF,OAAOH,I,iCAQT,SAA4BpC,GAC1B,IAAMwC,EAAQjC,SAASC,cAAc,SAKrC,OAHAgC,EAAMC,UAAW,EACjBD,EAAME,IAAMvG,KAAK+D,WAAWF,GAErBwC,I,wBAQT,SAAmBxC,GACjB,OAAQnG,OAAO8I,KAAO9I,OAAO+I,WAAWC,gBAAgB7C,Q","file":"crunker.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Crunker\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Crunker\"] = factory();\n\telse\n\t\troot[\"Crunker\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","export interface CrunkerConstructorOptions {\n  /**\n   * Sample rate for Crunker's internal audio context.\n   *\n   * @default 44100\n   */\n  sampleRate: number;\n}\n\nexport type CrunkerInputTypes = string | File | Blob;\n\n/**\n * An exported Crunker audio object.\n */\nexport interface ExportedCrunkerAudio {\n  blob: Blob;\n  url: string;\n  element: HTMLAudioElement;\n}\n\n/**\n * Crunker is the simple way to merge, concatenate, play, export and download audio files using the Web Audio API.\n */\nexport default class Crunker {\n  private readonly _sampleRate: number;\n  private readonly _context: AudioContext;\n\n  /**\n   * Creates a new instance of Crunker with the provided options.\n   */\n  constructor({ sampleRate = 44100 }: Partial<CrunkerConstructorOptions> = {}) {\n    this._sampleRate = sampleRate;\n    this._context = this._createContext();\n  }\n\n  /**\n   * Creates Crunker's internal AudioContext.\n   *\n   * @internal\n   */\n  private _createContext(): AudioContext {\n    window.AudioContext = window.AudioContext || (window as any).webkitAudioContext || (window as any).mozAudioContext;\n    return new AudioContext();\n  }\n\n  /**\n   * Asynchronously fetches multiple audio files and returns an array of AudioBuffers.\n   */\n  async fetchAudio(...filepaths: CrunkerInputTypes[]): Promise<AudioBuffer[]> {\n    return await Promise.all(\n      filepaths.map(async (filepath) => {\n        let buffer: ArrayBuffer;\n\n        if (filepath instanceof File || filepath instanceof Blob) {\n          buffer = await filepath.arrayBuffer();\n        } else {\n          buffer = await fetch(filepath).then((response) => {\n            if (response.headers.has('Content-Type') && !response.headers.get('Content-Type')!.includes('audio/')) {\n              console.warn(\n                `Crunker: Attempted to fetch an audio file, but its MIME type is \\`${\n                  response.headers.get('Content-Type')!.split(';')[0]\n                }\\`. We'll try and continue anyway. (file: \"${filepath}\")`\n              );\n            }\n\n            return response.arrayBuffer();\n          });\n        }\n\n        return await this._context.decodeAudioData(buffer);\n      })\n    );\n  }\n\n  /**\n   * Merges (layers) multiple AudioBuffers into a single AudioBuffer.\n   *\n   * **Visual representation:**\n   *\n   * ![](https://user-images.githubusercontent.com/12958674/88806278-968f0680-d186-11ea-9cb5-8ef2606ffcc7.png)\n   */\n  mergeAudio(buffers: AudioBuffer[]): AudioBuffer {\n    const output = this._context.createBuffer(\n      this._maxNumberOfChannels(buffers),\n      this._sampleRate * this._maxDuration(buffers),\n      this._sampleRate\n    );\n\n    buffers.forEach((buffer) => {\n      for (let channelNumber = 0; channelNumber < buffer.numberOfChannels; channelNumber++) {\n        const outputData = output.getChannelData(channelNumber);\n        const bufferData = buffer.getChannelData(channelNumber);\n\n        for (let i = buffer.getChannelData(channelNumber).length - 1; i >= 0; i--) {\n          outputData[i] += bufferData[i];\n        }\n\n        output.getChannelData(channelNumber).set(outputData);\n      }\n    });\n\n    return output;\n  }\n\n  /**\n   * Concatenates multiple AudioBuffers into a single AudioBuffer.\n   *\n   * **Visual representation:**\n   *\n   * ![](https://user-images.githubusercontent.com/12958674/88806297-9d1d7e00-d186-11ea-8cd2-c64cb0324845.png)\n   */\n  concatAudio(buffers: AudioBuffer[]): AudioBuffer {\n    const output = this._context.createBuffer(\n      this._maxNumberOfChannels(buffers),\n      this._totalLength(buffers),\n      this._sampleRate\n    );\n    let offset = 0;\n\n    buffers.forEach((buffer) => {\n      for (let channelNumber = 0; channelNumber < buffer.numberOfChannels; channelNumber++) {\n        output.getChannelData(channelNumber).set(buffer.getChannelData(channelNumber), offset);\n      }\n\n      offset += buffer.length;\n    });\n\n    return output;\n  }\n\n  /**\n   * Pads a specified AudioBuffer with silence from a specified start time,\n   * for a specified length of time.\n   *\n   * Accepts float values as well as whole integers.\n   *\n   * @param buffer AudioBuffer to pad\n   * @param padStart Time to start padding (in seconds)\n   * @param seconds Duration to pad for (in seconds)\n   */\n  padAudio(buffer: AudioBuffer, padStart: number = 0, seconds: number = 0): AudioBuffer {\n    if (seconds === 0) return buffer;\n\n    if (padStart < 0) throw new Error('Crunker: Parameter \"padStart\" in padAudio must be positive');\n    if (seconds < 0) throw new Error('Crunker: Parameter \"seconds\" in padAudio must be positive');\n\n    const updatedBuffer = this._context.createBuffer(\n      buffer.numberOfChannels,\n      Math.ceil(buffer.length + seconds * buffer.sampleRate),\n      buffer.sampleRate\n    );\n\n    for (let channelNumber = 0; channelNumber < buffer.numberOfChannels; channelNumber++) {\n      const channelData = buffer.getChannelData(channelNumber);\n      updatedBuffer\n        .getChannelData(channelNumber)\n        .set(channelData.subarray(0, Math.ceil(padStart * buffer.sampleRate) + 1), 0);\n\n      updatedBuffer\n        .getChannelData(channelNumber)\n        .set(\n          channelData.subarray(Math.ceil(padStart * buffer.sampleRate) + 2, updatedBuffer.length + 1),\n          Math.ceil((padStart + seconds) * buffer.sampleRate)\n        );\n    }\n\n    return updatedBuffer;\n  }\n\n  /**\n   * Plays the provided AudioBuffer in an AudioBufferSourceNode.\n   */\n  play(buffer: AudioBuffer): AudioBufferSourceNode {\n    const source = this._context.createBufferSource();\n\n    source.buffer = buffer;\n    source.connect(this._context.destination);\n    source.start();\n\n    return source;\n  }\n\n  /**\n   * Exports the specified AudioBuffer to a Blob, Object URI and HTMLAudioElement.\n   *\n   * Note that changing the MIME type does not change the actual file format. The\n   * file format will **always** be a WAVE file due to how audio is stored in the\n   * browser.\n   *\n   * @param buffer Buffer to export\n   * @param type MIME type (default: `audio/wav`)\n   */\n  export(buffer: AudioBuffer, type: string = 'audio/wav'): ExportedCrunkerAudio {\n    const recorded = this._interleave(buffer);\n    const dataview = this._writeHeaders(recorded);\n    const audioBlob = new Blob([dataview], { type });\n\n    return {\n      blob: audioBlob,\n      url: this._renderURL(audioBlob),\n      element: this._renderAudioElement(audioBlob),\n    };\n  }\n\n  /**\n   * Downloads the provided Blob.\n   *\n   * @param blob Blob to download\n   * @param filename An optional file name to use for the download (default: `crunker`)\n   */\n  download(blob: Blob, filename: string = 'crunker'): HTMLAnchorElement {\n    const a = document.createElement('a');\n\n    a.style.display = 'none';\n    a.href = this._renderURL(blob);\n    a.download = `${filename}.${blob.type.split('/')[1]}`;\n    a.click();\n\n    return a;\n  }\n\n  /**\n   * Executes a callback if the browser does not support the Web Audio API.\n   *\n   * Returns the result of the callback, or `undefined` if the Web Audio API is supported.\n   *\n   * @param callback callback to run if the browser does not support the Web Audio API\n   */\n  notSupported<T>(callback: () => T): T | undefined {\n    return this._isSupported() ? undefined : callback();\n  }\n\n  /**\n   * Closes Crunker's internal AudioContext.\n   */\n  close(): this {\n    this._context.close();\n    return this;\n  }\n\n  /**\n   * Returns the largest duration of the longest AudioBuffer.\n   *\n   * @internal\n   */\n  private _maxDuration(buffers: AudioBuffer[]): number {\n    return Math.max(...buffers.map((buffer) => buffer.duration));\n  }\n\n  /**\n   * Returns the largest number of channels in an array of AudioBuffers.\n   *\n   * @internal\n   */\n  private _maxNumberOfChannels(buffers: AudioBuffer[]): number {\n    return Math.max(...buffers.map((buffer) => buffer.numberOfChannels));\n  }\n\n  /**\n   * Returns the sum of the lengths of an array of AudioBuffers.\n   *\n   * @internal\n   */\n  private _totalLength(buffers: AudioBuffer[]): number {\n    return buffers.map((buffer) => buffer.length).reduce((a, b) => a + b, 0);\n  }\n\n  /**\n   * Returns whether the browser supports the Web Audio API.\n   *\n   * @internal\n   */\n  private _isSupported(): boolean {\n    return 'AudioContext' in window || 'webkitAudioContext' in window || 'mozAudioContext' in window;\n  }\n\n  /**\n   * Writes the WAV headers for the specified Float32Array.\n   *\n   * Returns a DataView containing the WAV headers and file content.\n   *\n   * @internal\n   */\n  private _writeHeaders(buffer: Float32Array): DataView {\n    const arrayBuffer = new ArrayBuffer(44 + buffer.length * 2);\n    const view = new DataView(arrayBuffer);\n\n    this._writeString(view, 0, 'RIFF');\n    view.setUint32(4, 32 + buffer.length * 2, true);\n    this._writeString(view, 8, 'WAVE');\n    this._writeString(view, 12, 'fmt ');\n    view.setUint32(16, 16, true);\n    view.setUint16(20, 1, true);\n    view.setUint16(22, 2, true);\n    view.setUint32(24, this._sampleRate, true);\n    view.setUint32(28, this._sampleRate * 4, true);\n    view.setUint16(32, 4, true);\n    view.setUint16(34, 16, true);\n    this._writeString(view, 36, 'data');\n    view.setUint32(40, buffer.length * 2, true);\n\n    return this._floatTo16BitPCM(view, buffer, 44);\n  }\n\n  /**\n   * Converts a Float32Array to 16-bit PCM.\n   *\n   * @internal\n   */\n  private _floatTo16BitPCM(dataview: DataView, buffer: Float32Array, offset: number): DataView {\n    for (let i = 0; i < buffer.length; i++, offset += 2) {\n      const tmp = Math.max(-1, Math.min(1, buffer[i]));\n      dataview.setInt16(offset, tmp < 0 ? tmp * 0x8000 : tmp * 0x7fff, true);\n    }\n\n    return dataview;\n  }\n\n  /**\n   * Writes a string to a DataView at the specified offset.\n   *\n   * @internal\n   */\n  private _writeString(dataview: DataView, offset: number, header: string): void {\n    for (let i = 0; i < header.length; i++) {\n      dataview.setUint8(offset + i, header.charCodeAt(i));\n    }\n  }\n\n  /**\n   * Converts an AudioBuffer to a Float32Array.\n   *\n   * @internal\n   */\n  private _interleave(input: AudioBuffer): Float32Array {\n    const buffer = input.getChannelData(0),\n      length = buffer.length * 2,\n      result = new Float32Array(length);\n\n    let index = 0,\n      inputIndex = 0;\n\n    while (index < length) {\n      result[index++] = buffer[inputIndex];\n      result[index++] = buffer[inputIndex];\n      inputIndex++;\n    }\n    return result;\n  }\n\n  /**\n   * Creates an HTMLAudioElement whose source is the specified Blob.\n   *\n   * @internal\n   */\n  private _renderAudioElement(blob: Blob): HTMLAudioElement {\n    const audio = document.createElement('audio');\n\n    audio.controls = true;\n    audio.src = this._renderURL(blob);\n\n    return audio;\n  }\n\n  /**\n   * Creates an Object URL for the specified Blob.\n   *\n   * @internal\n   */\n  private _renderURL(blob: Blob): string {\n    return (window.URL || window.webkitURL).createObjectURL(blob);\n  }\n}\n"],"sourceRoot":""}