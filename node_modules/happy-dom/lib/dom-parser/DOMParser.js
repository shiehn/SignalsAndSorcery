"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const XMLParser_1 = __importDefault(require("../xml-parser/XMLParser"));
const Node_1 = __importDefault(require("../nodes/node/Node"));
const DOMException_1 = __importDefault(require("../exception/DOMException"));
const HTMLDocument_1 = __importDefault(require("../nodes/html-document/HTMLDocument"));
const XMLDocument_1 = __importDefault(require("../nodes/xml-document/XMLDocument"));
const SVGDocument_1 = __importDefault(require("../nodes/svg-document/SVGDocument"));
/**
 * DOM parser.
 *
 * Reference:
 * https://developer.mozilla.org/en-US/docs/Web/API/DOMParser.
 */
class DOMParser {
    /**
     * Parses HTML and returns a root element.
     *
     * @param string HTML data.
     * @param mimeType Mime type.
     * @returns Root element.
     */
    parseFromString(string, mimeType) {
        if (!mimeType) {
            throw new DOMException_1.default('Second parameter "mimeType" is mandatory.');
        }
        const ownerDocument = this.constructor._ownerDocument;
        const newDocument = this._createDocument(mimeType);
        newDocument.defaultView = ownerDocument.defaultView;
        newDocument.childNodes.length = 0;
        newDocument.children.length = 0;
        const root = XMLParser_1.default.parse(newDocument, string, true);
        let documentElement = null;
        let documentTypeNode = null;
        for (const node of root.childNodes) {
            if (node['tagName'] === 'HTML') {
                documentElement = node;
            }
            else if (node.nodeType === Node_1.default.DOCUMENT_TYPE_NODE) {
                documentTypeNode = node;
            }
            if (documentElement && documentTypeNode) {
                break;
            }
        }
        if (documentElement) {
            if (documentTypeNode) {
                newDocument.appendChild(documentTypeNode);
            }
            newDocument.appendChild(documentElement);
            const body = newDocument.querySelector('body');
            if (body) {
                for (const child of root.childNodes.slice()) {
                    body.appendChild(child);
                }
            }
        }
        else {
            const documentElement = newDocument.createElement('html');
            const bodyElement = newDocument.createElement('body');
            const headElement = newDocument.createElement('head');
            documentElement.appendChild(headElement);
            documentElement.appendChild(bodyElement);
            newDocument.appendChild(documentElement);
            for (const node of root.childNodes.slice()) {
                bodyElement.appendChild(node);
            }
        }
        return newDocument;
    }
    /**
     *
     * @param mimeType Mime type.
     * @returns Document.
     */
    _createDocument(mimeType) {
        switch (mimeType) {
            case 'text/html':
                return new HTMLDocument_1.default();
            case 'image/svg+xml':
                return new SVGDocument_1.default();
            case 'text/xml':
            case 'application/xml':
            case 'application/xhtml+xml':
                return new XMLDocument_1.default();
            default:
                throw new DOMException_1.default(`Unknown mime type "${mimeType}".`);
        }
    }
}
exports.default = DOMParser;
DOMParser._ownerDocument = null;
//# sourceMappingURL=DOMParser.js.map